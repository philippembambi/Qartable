<?php
dl();
?>
ConfidentialitÃ©ConfidentialitÃ©
PrimFX.com

    Accueil
    Formations
    Forum
    Connexion
    Inscription

Tutos > PHP
IntÃ©grer PayPal Express Checkout Ã  son site en PHP
PrimFX Boris ('PrimFX') Le 10 mars 2018
Sommaire

    Introduction
    Payer via PayPal : Comment Ã§a marche ?
    Rappels sur certaines notions abordÃ©es dans ce cours
    Obtenir des Credentials
    IntÃ©gration du systÃ¨me de paiement
    Tests du systÃ¨me et passage en Live
    Vendre diffÃ©rents produits

Apprendre Ã  grande vitesse. Les cours vidÃ©o en ligne sont Ã  partir de 9,99 â‚¬
IntÃ©gration du systÃ¨me de paiement
CrÃ©ation de notre page de paiement (cÃ´tÃ© client HTML & JS)

Ã‡a y est, nous y sommes, il est (enfin) temps de commencer Ã  intÃ©grer notre systÃ¨me de paiement sur une page web ğŸ˜€ CommenÃ§ons par quelque chose dâ€™Ã©lÃ©mentaire : crÃ©er une page HTML, relativement simple, qui se chargera simplement dâ€™afficher un bouton de paiement PayPal (documentation ici).

Pour se faire, PayPal met Ã  notre disposition un script JS tout fait qui nous permettra de gÃ©nÃ©rer le bouton automatiquement . Ce script se trouve Ã  lâ€™adresse https://www.paypalobjects.com/api/checkout.js. Nous aurons donc un document HTML dans lequel nous devrons :

    Importer le script JS fourni par PayPal
    CrÃ©er une div avec un ID spÃ©cifique afin de lâ€™identifier en tant que bouton de paiement
    Ajouter du code JS en fin de document (avant la fermeture de la balise <body>) afin de gÃ©nÃ©rer le bouton de paiement

J'appellerai dans mon cas ce fichier "index.html", qui sera Ã  la racine du site internet. Bien sÃ»r, il s'agit-lÃ  d'une faÃ§on trÃ¨s simple d'afficher et de tester par la suite ce systÃ¨me de paiement. Par la suite, il sera plus logique de l'intÃ©grer sur des pages de votre site spÃ©cifiques au paiement d'un produit... Bref, voici Ã  quoi ressemble le code de cette page (que j'ai directement commentÃ© afin qu'il soit comprÃ©hensible) :

	<html>
	<head>
	  <title>Page de paiement</title>
	  <meta charset="utf-8">
	  <script src="https://www.paypalobjects.com/api/checkout.js"></script>
	</head>
	<body>
	  <div id="bouton-paypal"></div>
	  <script>
	    paypal.Button.render({
	      env: 'sandbox', // Ou 'production',
	      commit: true, // Affiche le bouton  "Payer maintenant"
	      style: {
	        color: 'gold', // ou 'blue', 'silver', 'black'
	        size: 'responsive' // ou 'small', 'medium', 'large'
	        // Autres options de style disponibles ici : https://developer.paypal.com/docs/integration/direct/express-checkout/integration-jsv4/customize-button/
	      },
	      payment: function(data, actions) {
	        /* 
	         * CrÃ©ation du paiement
	         */
	        console.log('paiement crÃ©Ã©');
	      },
	      onAuthorize: function(data, actions) {
	        /* 
	         * ExÃ©cution du paiement 
	         */
	      },
	      onCancel: function(data, actions) {
	        /* 
	         * L'acheteur a annulÃ© le paiement
	         */
	      },
	      onError: function(err) {
	        /* 
	         * Une erreur est survenue durant le paiement 
	         */
	      }
	    }, '#bouton-paypal');
	  </script>
	</body>
	</html>

J'ai Ã©galement volontairement choisi d'appeler ce fichier "index.html" pour bien vous montrer la dissociation des parties client / serveur. En effet, aucun code serveur (PHP dans notre cas) n'est requis sur cette page. Bien sÃ»r, dans la pratique, vous pourrez tout aussi bien intÃ©grer ce code cÃ´tÃ© client sur une page en PHP ("index.php" par exemple ğŸ˜‰).

Pour rÃ©sumer le fonctionnement de ce script, le script checkout.js fourni par PayPal nous permet dâ€™assigner une div ayant un id spÃ©cifique Ã  ce qui sera finalement un bouton de paiement via PayPal. La fonction principale du code, paypal.Button.render permet de gÃ©nÃ©rer ce bouton (comme son nom lâ€™indique) Ã  partir de divers paramÃ¨tres, dont la plupart sont des fonctions. En effet, Express Checkout repose sur un principe de callbacks (fonctions) client-side qui nous permettront de dÃ©clencher diffÃ©rentes actions en fonction de lâ€™interaction quâ€™aura un internaute avec le bouton. Ainsi, une fonction est prÃ©vue au moment du clic sur le bouton, une autre au moment de la validation du paiement, etc.

Jâ€™ai volontairement rajoutÃ© un petit console.log() dans le callback de Â« payment Â», vous pouvez donc tester ce script, et verrez que lorsque vous cliquerez sur le bouton de paiement PayPal, le message Â« paiement crÃ©Ã© Â» sera automatiquement loggÃ© dans la console JS de votre navigateur : on peut donc bien surveiller ce qui se passe sur notre bouton de paiement, et câ€™est lÃ  la base dâ€™Express Checkoutâ€¦ On se rapproche du but mâ€™voyez ğŸ˜€
Mise en place de la base de donnÃ©es pour le stockage des informations des paiements

Dans un premier temps, avant de crÃ©er le moindre code PHP, il va nous falloir crÃ©er dans notre base de donnÃ©es une table intitulÃ©e par exemple Â« paiements Â» qui nous permettra de stocker diverses informations communiquÃ©es par PayPal Ã  lâ€™Ã©gard des paiements que nous effectuerons.

Je vais donc vous demander de me faire confiance sur ce coup, puisque lâ€™appellation ou lâ€™utilitÃ© de certains champs vous paraÃ®tra certainement un peu abstraite pour lâ€™instant. Ne vous en faites pas, tout sâ€™Ã©claircira au fur et Ã  mesure que lâ€™on Ã©crira le code PHP pour traiter les paiements. Seulement, le processus de rÃ©alisation dâ€™un paiement utilisant la mÃ©thode dâ€™intÃ©gration server-side REST impose lâ€™utilisation dâ€™une base de donnÃ©es en particulier pour une information trÃ¨s importante : l'id du paiement gÃ©nÃ©rÃ© par PayPalâ€¦ (mais Ã  nouveau, nous parlerons de cela un peu plus tard ğŸ˜›)

Voici donc la table que je vous propose de crÃ©er dans votre base de donnÃ©es : En SQL, Ã§a donne Ã§a :

	CREATE TABLE `paiements` (
	 `id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
	 `payment_id` varchar(255) NOT NULL,
	 `payment_status` text NOT NULL,
	 `payment_amount` text NOT NULL,
	 `payment_currency` text NOT NULL,
	 `payment_date` datetime NOT NULL,
	 `payer_email` text NOT NULL
	);

Les champs de cette table sont volontairement tous en anglais pour une simple raison : lâ€™API de PayPal nous retournera des valeurs dont les noms seront eux aussi en anglais, et je peux vous assurer quâ€™il est bien plus agrÃ©able de travailler avec des noms similaires entre base de donnÃ©es et API que dâ€™avoir Ã  faire la traduction pour savoir quel champ correspond Ã  quelle donnÃ©e envoyÃ©e par lâ€™API. Si vous Ãªtes donc assez Ã  lâ€™aise avec lâ€™anglais pour que travailler avec de tels noms de champs ne sâ€™avÃ¨re pas incomprÃ©hensible ou gÃªnant pour vous, je vous invite donc Ã  faire de mÃªme en conservant les noms en anglais. Vous avez mÃªme le droit Ã  une petite description de chaque champ ğŸ˜‰ :

    id : un identifiant unique pour trier nos entrÃ©es dans la table et qui est auto-incrÃ©mentÃ© automatiquement par MySQL
    payment_id : lâ€™identifiant unique dâ€™un paiement, gÃ©nÃ©rÃ© et renvoyÃ© par PayPal lors de lâ€™initialisation dâ€™un paiement
    payment_status : le statut du paiement (crÃ©Ã©, approuvÃ©, annulÃ©, etc.)
    payment_amount : montant du paiement
    payment_currency : la devise du paiement (EUR, USD, etc.)
    payment_date : la date et lâ€™heure de crÃ©ation du paiement, ce sera un simple NOW() dans nos requÃªtes SQL
    payer_email : lâ€™email PayPal du client (rÃ©cupÃ©rÃ© via lâ€™API PayPal)

CrÃ©ation d'un paiement (PHP)

Lorsquâ€™un utilisateur cliquera sur notre bouton de paiement, câ€™est la fonction Â« payment Â» qui sera appelÃ©e cÃ´tÃ© client. Il nous faudra ainsi Ã  partir de cette fonction appeler un script cÃ´tÃ© serveur qui se chargera de crÃ©er le paiement, câ€™est-Ã -dire indiquer Ã  PayPal que lâ€™on souhaite initialiser un paiement et enregistrer en base de donnÃ©es les informations du paiement une fois celui-ci correctement initialisÃ©. Nous appellerons ce script Â« paypal_create_payment.php Â», dans un dossier Â« php Â».

Prenons donc notre code Ã©tape par Ã©tape :

On commence par inclure nos Ã©ventuels fichiers de configuration, essentiels au bon fonctionnement du site. Dans mon cas, en guise d'exemple, j'inclurai simplement un fichier "php/config.php" contenant l'initialisation d'une session (session_start()) dont le classe PayPalPayment aura besoin pour fonctionner correctement ainsi qu'une connexion PDO Ã  la base de donnÃ©es. On peut ensuite directement inclure la classe PayPalPayment dont on aura besoin. Il s'agit de la classe dont je parlais dans un chapitre prÃ©cÃ©dent, toujours disponible sur mon GitHub. On a donc le code qui suit :

	<?php
	require_once "config.php"; // On est dÃ©jÃ  dans le dossier "php" Ã  la racine de notre site, on peut donc directement inclure "config.php" qui se trouve dans ce mÃªme dossier
	require_once "../class/PayPalPayment.php"; // On inclue les fichiers relativement Ã  la position du fichier actuel, qui est dÃ©jÃ  dans le dossier "php"
	

Etant donnÃ© que notre communication client/serveur se basera sur du JSON, on pourra une fois notre script terminÃ© envoyer diffÃ©rentes informations Ã  notre cÃ´tÃ© client. On initialise donc en dÃ©but de fichiers quelques variables dont :

    success qui sera un boolÃ©en (0 ou 1) permettant de savoir si tout s'est passÃ© correctement ou non
    msg qui contiendra un message d'erreur (initialisÃ© par dÃ©faut pour une erreur quelconque)
    paypal_response qui contiendra tout ce que PayPal nous enverra via son API 

	$success = 0;
	$msg = "Une erreur est survenue, merci de bien vouloir rÃ©essayer ultÃ©rieurement...";
	$paypal_response = [];

On peut ensuite initialiser un objet Ã  partir de notre classe PayPalPayment et le configurer correctement Ã  l'aide de quelques fonctions prÃ©-conÃ§ues :

	$payer->setSandboxMode(1); // On active le mode Sandbox
	$payer->setClientID("Votre Client ID"); // On indique sont Client ID
	$payer->setSecret("Votre Secret"); // On indique son Secret

On met ensuite en place toutes les informations de paiement requises par PayPal. A noter que les donnÃ©es Ã  fournir Ã  PayPal sont dÃ©taillÃ©es par ici et quâ€™il est extrÃªmement important de respecter la structure de donnÃ©es imposÃ©e par PayPal ainsi que dâ€™inclure les donnÃ©es obligatoires afin que le paiement puisse Ãªtre initialisÃ© sans problÃ¨me. Vous noterez que les donnÃ©es Ã  renseigner sont globalement assez Ã©videntes, leurs noms respectifs parlants d'eux-mÃªmes.

	$payment_data = [
	   "intent" => "sale",
	   "redirect_urls" => [
	      "return_url" => "http://localhost/",
	      "cancel_url" => "http://localhost/"
	   ],
	   "payer" => [
	      "payment_method" => "paypal"
	   ],
	   "transactions" => [
	      [
	         "amount" => [
	            "total" => "9.99", // Prix total de la transaction, ici le prix de notre item
	            "currency" => "EUR" // USD, CAD, etc.
	         ],
	         "item_list" => [
	            "items" => [
	               [
	                  "sku" => "1PK5Z9", // Un identifiant quelconque (code / rÃ©fÃ©rence) que vous pouvez attribuer au produit que vous vendez
	                  "quantity" => "1",
	                  "name" => "Un produit quelconque",
	                  "price" => "9.99",
	                  "currency" => "EUR"
	               ]
	            ]
	         ],
	         "description" => "Description du paiement..."
	      ]
	   ]
	];

Les "redirect URLs" sont des URLs permettant de rediriger l'utilisateur lorsque le paiement a rÃ©ussi (return_url) ou lorsque celui-ci a Ã©chouÃ© / Ã©tÃ© annulÃ© (cancel_url). Seulement, ces URLs, bien que toujours obligatoires Ã  prÃ©ciser, ne sont plus utilisÃ©es par le nouveau systÃ¨me Express Checkout. Vous pouvez donc les laisser Ã  la racine de votre site internet par exemple.

On utilise la fonction "createPayment" de la classe PayPalPayment (donc depuis la variable $payer) en lui passant toutes nos donnÃ©es crÃ©Ã©es ci-dessus pour initialiser le paiement. Cette fonction renvoie la rÃ©ponse du serveur PayPal. Cette rÃ©ponse contient des donnÃ©es au format JSON, on doit donc les dÃ©coder pour les utiliser comme des tableaux / objets en PHP :

	$paypal_response = $payer->createPayment($payment_data);
	$paypal_response = json_decode($paypal_response);

Si dans la rÃ©ponse de PayPal on a bien un "id" que PayPal a gÃ©nÃ©rÃ© (et qui est l'identifiant unique de notre paiement en cours), alors on peut continuer :

if (!empty($paypal_response->id)) {

On insert ici une nouvelle entrÃ©e dans notre table "paiements" afin de stocker le paiement initialisÃ© avec les informations que nous avons dÃ©jÃ  (grÃ¢ce Ã  l'API PayPal).

$insert = $bdd->prepare("INSERT INTO paiements (payment_id, payment_status, payment_amount, payment_currency, payment_date, payer_email, payer_paypal_id, payer_first_name, payer_last_name) VALUES (:payment_id, ğŸ˜›ayment_status, ğŸ˜›ayment_amount, ğŸ˜›ayment_currency, NOW(), '', '', '', '')");

Lors de l'exÃ©cution de la requÃªte avec les diffÃ©rentes donnÃ©es, on prend soin de rÃ©cupÃ©rer le statut de l'exÃ©cution dans une nouvelle variable. $insert_ok est un boolÃ©en qui vaudra 1 si la requÃªte a bien Ã©tÃ© exÃ©cutÃ©e, sinon 0.

	$insert_ok = $insert->execute(array(
	         "payment_id" => $paypal_response->id,
	         "payment_status" => $paypal_response->state,
	         "payment_amount" => $paypal_response->transactions[0]->amount->total,
	         "payment_currency" => $paypal_response->transactions[0]->amount->currency,
	      ));

Toutes les donnÃ©es passÃ©es en paramÃ¨tre ici proviennent directement de la rÃ©ponse du serveur de PayPal. Pour voir Ã  quoi ressemble la structure de l'intÃ©gralitÃ© des donnÃ©es renvoyÃ©es par PayPal lors de cette Ã©tape de crÃ©ation du paiement, c'est par ici : https://developer.paypal.com/docs/integration/direct/express-checkout/integration-jsv4/advanced-payments-api/create-express-checkout-payments/#response

Si le paiement initialisÃ© a bien Ã©tÃ© enregistrÃ© en base de donnÃ©es, on peut dire que l'initialisation du paiement a entiÃ¨rement fonctionnÃ© et on peut donc passer $succes Ã  1. On peut Ã©galement vider le $msg puisque rien n'aura besoin d'Ãªtre affichÃ© Ã  notre client si le paiement a Ã©tÃ© normalement crÃ©Ã©.

	if ($insert_ok) {
	   $success = 1;
	   $msg = "";
	}

Pourquoi le $success ne peut-il pas Ãªtre passÃ© Ã  1 plus tÃ´t ? Par exemple aprÃ¨s la rÃ©cupÃ©ration des informations du paiement par PayPal ? Simplement car nous aurons besoin plus tard d'identifier ce paiement via son ID (gÃ©nÃ©rÃ© par PayPal) et se trouvant de le champ "payment_id" de notre table. Il faut donc OBLIGATOIREMENT que le paiement ait Ã©tÃ© ajoutÃ© en base de donnÃ©es avant de le considÃ©rer comme valide.

Si l'on n'a pas d'ID de paiement communiquÃ© par PayPal (condition crÃ©Ã©e quelques paragraphes plus haut), on peut Ã©ventuellement modifier notre $msg d'erreur afin qu'il corresponde au problÃ¨me rencontrÃ© :

	} else {
	   $msg = "Une erreur est survenue durant la communication avec les serveurs de PayPal. Merci de bien vouloir rÃ©essayer ultÃ©rieurement.";
	}

Enfin, on affiche un tableau de donnÃ©es qui sera rÃ©cupÃ©rÃ© par notre client-side, encodÃ© en JSON pour des raisons pratiques de communication client/serveur :

echo json_encode(["success" => $success, "msg" => $msg, "paypal_response" => $paypal_response]);

Voici Ã  quoi ressemblera donc notre code de crÃ©ation de paiement en PHP une fois terminÃ© :

	<?php
	require_once "config.php";
	require_once "../class/PayPalPayment.php";
	 
	$success = 0;
	$msg = "Une erreur est survenue, merci de bien vouloir rÃ©essayer ultÃ©rieurement...";
	$paypal_response = [];
	 
	$payer = new PayPalPayment();
	$payer->setSandboxMode(1);
	$payer->setClientID("Votre Client ID");
	$payer->setSecret("Votre Secret");
	 
	$payment_data = [
	   "intent" => "sale",
	   "redirect_urls" => [
	      "return_url" => "http://localhost/",
	      "cancel_url" => "http://localhost/"
	   ],
	   "payer" => [
	      "payment_method" => "paypal"
	   ],
	   "transactions" => [
	      [
	         "amount" => [
	            "total" => "9.99",
	            "currency" => "EUR"
	         ],
	         "item_list" => [
	            "items" => [
	               [
	                  "sku" => "1PK5Z9",
	                  "quantity" => "1",
	                  "name" => "Un produit quelconque",
	                  "price" => "9.99",
	                  "currency" => "EUR"
	               ]
	            ]
	         ],
	         "description" => "Description du paiement..."
	      ]
	   ]
	];
	 
	$paypal_response = $payer->createPayment($payment_data);
	$paypal_response = json_decode($paypal_response);
	 
	if (!empty($paypal_response->id)) {
	   $insert = $bdd->prepare("INSERT INTO paiements (payment_id, payment_status, payment_amount, payment_currency, payment_date, payer_email, payer_paypal_id, payer_first_name, payer_last_name) VALUES (:payment_id, ğŸ˜›ayment_status, ğŸ˜›ayment_amount, ğŸ˜›ayment_currency, NOW(), '', '', '', '')");
	   
	   $insert_ok = $insert->execute(array(
	         "payment_id" => $paypal_response->id,
	         "payment_status" => $paypal_response->state,
	         "payment_amount" => $paypal_response->transactions[0]->amount->total,
	         "payment_currency" => $paypal_response->transactions[0]->amount->currency,
	      ));
	 
	   if ($insert_ok) {
	      $success = 1;
	      $msg = "";
	   }
	} else {
	   $msg = "Une erreur est survenue durant la communication avec les serveurs de PayPal. Merci de bien vouloir rÃ©essayer ultÃ©rieurement.";
	}
	 
	echo json_encode(["success" => $success, "msg" => $msg, "paypal_response" => $paypal_response]);
	

ExÃ©cution du paiement

Sur le mÃªme principe que le script de crÃ©ation de paiement appelÃ© lors du clic sur le bouton de paiement via la fonction cÃ´tÃ© client "payment", la fonction "onAuthorize" sera automatiquement appelÃ©e cÃ´tÃ© client lorsqu'un utilisateur confirmera (autorisera) le paiement crÃ©Ã© plus tÃ´t. Dans cette fonction "onAuthorize", il va nous falloir appeler un nouveau script cÃ´tÃ© serveur qui se chargera de valider et finaliser le paiement. Nous appellerons ce script "paypal_execute_payment", toujours dans le dossier "php".

A nouveau, dÃ©composons notre script d'exÃ©cution :

Dans un premier temps, tout comme pour le script de crÃ©ation d'un paiement, il va nous falloir importer quelques ressources et initialiser un certain nombre de variables, rien de nouveau pour l'instant :

	<?php
	require_once "config.php";
	require_once "../class/PayPalPayment.php";
	 
	$success = 0;
	$msg = "Une erreur est survenue, merci de bien vouloir rÃ©essayer ultÃ©rieurement...";
	$paypal_response = [];
	

Dans le script de crÃ©ation de paiement, on demandait simplement Ã  PayPal d'initialiser un paiement. On n'avait donc besoin d'aucun paramÃ¨tre dans notre script. Dans le cas de l'exÃ©cution d'un paiement, les choses sont un peu diffÃ©rentes. En effet, a prÃ©sent, PayPal se chargera via notre script cÃ´tÃ© client (en JS) de nous faire parvenir deux paramÃ¨tres importants via la mÃ©thode POST : "paymentID" et "payerID". Ces deux paramÃ¨tres sont essentiels au bon dÃ©roulement de la finalisation de notre paiement : ils nous permettront dans un premier temps de rÃ©cupÃ©rer le paiement crÃ©Ã© plus tÃ´t dans notre base de donnÃ©es (via le paymentID, appelÃ© "payment_id" dans notre base de donnÃ©es) et par la suite d'envoyer la demande de finalisation Ã  PayPal dont l'API nÃ©cessite les deux paramÃ¨tres rÃ©unis (paymentID et payerID).

Nous pouvons donc dÃ¨s Ã  prÃ©sent vÃ©rifier que ces paramÃ¨tres contiennent bien quelque chose, et si c'est le cas les sÃ©curiser un minimum en les plaÃ§ant dans de nouvelles variables :

	if (!empty($_POST['paymentID']) AND !empty($_POST['payerID'])) {
	   $paymentID = htmlspecialchars($_POST['paymentID']);
	   $payerID = htmlspecialchars($_POST['payerID']);

On peut Ã  prÃ©sent initialiser une instance de la classe PayPalPayment, comme pour la crÃ©ation du paiement :

	   $payer = new PayPalPayment();
	   $payer->setSandboxMode(1);
	   $payer->setClientID("Votre Client ID");
	   $payer->setSecret("Votre Secret");

On tente maintenant de rÃ©cupÃ©rer le paiement Ã  exÃ©cuter dans notre base de donnÃ©es Ã  partir de son "payment_id", correspondant au paramÃ¨tre POST "paymendID" passÃ© en paramÃ¨tre par PayPal (et que l on a enregistrÃ© un peu plus haut dans la variable $paymentID) :

	   $payment = $bdd->prepare('SELECT * FROM paiements WHERE payment_id = ?');
	   $payment->execute(array($paymentID));
	   $payment = $payment->fetch();

Si le paiement est bien trouvÃ© dans notre base de donnÃ©es, on peut continuer :

   if ($payment) {

On exÃ©cute le paiement via la fonction "executePayment" dans laquelle on doit passer les paramÃ¨tres paymentID et payerID. Cette fonction de la classe PayPalPayment se chargera pour nous de contacter les serveurs de PayPal via leur API et de nous donner quelques informations en retour que nous traiterons par la suite. On peut d'ailleurs par la mÃªme occasion dÃ©coder ces donnÃ©es reÃ§ues au format JSON :

	      $paypal_response = $payer->executePayment($paymentID, $payerID);
	      $paypal_response = json_decode($paypal_response);

Maintenant que nous avons la rÃ©ponse de PayPal enregistrÃ©e dans $paypal_response avec toutes les informations sur le paiement, on peut mettre Ã  jour ce paiement dans notre base de donnÃ©es. On se chargera notamment de mettre Ã  jour le statut du paiement (qui nous permettra de savoir si le paiement a bien Ã©tÃ© validÃ© ou bien s'il a Ã©chouÃ©) ainsi que l'email PayPal de notre client, toujours en se basant sur le "payment_id" pour savoir quel champ mettre Ã  jour :

	      $update_payment = $bdd->prepare('UPDATE paiements SET payment_status = ?, payer_email = ? WHERE payment_id = ?');
	      $update_payment->execute(array($paypal_response->state, $paypal_response->payer->payer_info->email, $paymentID));

Et si je veux rÃ©cupÃ©rer d'autres informations sur le paiement / le client ? Les donnÃ©es stockÃ©es dans "$paypal_response" et provenant de la requÃªte d'exÃ©cution de paiement de l'API PayPal sont dÃ©taillÃ©es dans la documentation de PayPal. Vous y trouverez le dÃ©tail de la structure renvoyÃ©e par l'API.

A prÃ©sent, on vÃ©rifie si le paiement a bien Ã©tÃ© approuvÃ©, grÃ¢ce Ã  la donnÃ©e stockÃ©e dans "$paypal_response->state" :

      if ($paypal_response->state == "approved") {

A ce stade, le paiement a Ã©tÃ© entiÃ¨rement validÃ©, on peut envoyer Ã  l'utilisateur le produit commandÃ©, lui envoyer un email contenant une facture du paiement, etc. En particulier, on peut passer notre variable $success Ã  1 pour indiquer que le paiement Ã  bien rÃ©ussi Ã  notre cÃ´tÃ© client, et vider notre $msg d'erreur potentiel (puisqu'il n'y a plus d'erreur Ã  ce stade du paiement) :

	         $success = 1;
	         $msg = "";

Si le paiement n'a pas Ã©tÃ© approuvÃ©, on modifie le message d'erreur pour informer l'utilisateur du problÃ¨me rencontrÃ© :

	      } else {
	         $msg = "Une erreur est survenue durant l'approbation de votre paiement. Merci de rÃ©essayer ultÃ©rieurement ou contacter un administrateur du site.";
	      }

De mÃªme, si le paiement n'a pas Ã©tÃ© trouvÃ© dans notre base de donnÃ©es, on en informe l'utilisateur :

	   } else {
	      $msg = "Votre paiement n'a pas Ã©tÃ© trouvÃ© dans notre base de donnÃ©es. Merci de rÃ©essayer ultÃ©rieurement ou contacter un administrateur du site. (Votre compte PayPal n'a pas Ã©tÃ© dÃ©bitÃ©)";
	   }

Finalement, on peut fermer l'accolade de notre premiÃ¨re condition sur la prÃ©sence des paramÃ¨tres "$_POST['paymentID']" et "$_POST['payerID']" et terminer par afficher quelques informations en JSON qui seront rÃ©cupÃ©rÃ©es par notre code JS cÃ´tÃ© client, de la mÃªme faÃ§on que nous l'avions fait pour le script de crÃ©ation de paiement :

	}
	echo json_encode(["success" => $success, "msg" => $msg, "paypal_response" => $paypal_response]);

Voici Ã  quoi ressemblera donc le script d\exÃ©cution de paiement dans sa totalitÃ© :

	<?php
	require_once "config.php";
	require_once "../class/PayPalPayment.php";
	 
	$success = 0;
	$msg = "Une erreur est survenue, merci de bien vouloir rÃ©essayer ultÃ©rieurement...";
	$paypal_response = [];
	 
	if (!empty($_POST['paymentID']) AND !empty($_POST['payerID'])) {
	   $paymentID = htmlspecialchars($_POST['paymentID']);
	   $payerID = htmlspecialchars($_POST['payerID']);
	 
	   $payer = new PayPalPayment();
	   $payer->setSandboxMode(1);
	   $payer->setClientID("Votre Client ID");
	   $payer->setSecret("Votre Secret");
	 
	   $payment = $bdd->prepare('SELECT * FROM paiements WHERE payment_id = ?');
	   $payment->execute(array($paymentID));
	   $payment = $payment->fetch();
	 
	   if ($payment) {
	      $paypal_response = $payer->executePayment($paymentID, $payerID);
	      $paypal_response = json_decode($paypal_response);
	 
	      $update_payment = $bdd->prepare('UPDATE paiements SET payment_status = ?, payer_email = ? WHERE payment_id = ?');
	      $update_payment->execute(array($paypal_response->state, $paypal_response->payer->payer_info->email, $paymentID));
	 
	      if ($paypal_response->state == "approved") {
	         $success = 1;
	         $msg = "";
	      } else {
	         $msg = "Une erreur est survenue durant l'approbation de votre paiement. Merci de rÃ©essayer ultÃ©rieurement ou contacter un administrateur du site.";
	      }
	   } else {
	      $msg = "Votre paiement n'a pas Ã©tÃ© trouvÃ© dans notre base de donnÃ©es. Merci de rÃ©essayer ultÃ©rieurement ou contacter un administrateur du site. (Votre compte PayPal n'a pas Ã©tÃ© dÃ©bitÃ©)";
	   }
	}
	echo json_encode(["success" => $success, "msg" => $msg, "paypal_response" => $paypal_response]);
	

Liaison client/serveur

Il ne nous reste Ã  prÃ©sent plus qu'Ã  permettre Ã  nos scripts cÃ´tÃ©s client et serveur de communiquer entre eux. Dans la pratique, la seule chose Ã  modifier sera notre script JS cÃ´tÃ© client afin que celui-ci effectue des requÃªtes sur nos scripts PHP pour ensuite rÃ©cupÃ©rer les informations que nous avons passÃ© dans nos "echo" (vous savez, les fameux tableaux encodÃ©s en JSON). Je vous propose donc de vous afficher directement le script JS que nous avions crÃ©Ã© auparavant mais avec les modifications permettant la communication client/serveur, et avec bien sÃ»r pas mal de commentaires histoire que le code soit comprÃ©hensible :

	paypal.Button.render({
	      env: 'sandbox', // Ou 'production',
	      commit: true, // Affiche le bouton  "Payer maintenant"
	      style: {
	        color: 'gold', // ou 'blue', 'silver', 'black'
	        size: 'responsive' // ou 'small', 'medium', 'large'
	        // Autres options de style disponibles ici : https://developer.paypal.com/docs/integration/direct/express-checkout/integration-jsv4/customize-button/
	      },
	      payment: function() {
	        // On crÃ©e une variable contenant le chemin vers notre script PHP cÃ´tÃ© serveur qui se chargera de crÃ©er le paiement
	        var CREATE_URL = '/php/paypal_create_payment.php';
	        // On exÃ©cute notre requÃªte pour crÃ©er le paiement
	        return paypal.request.post(CREATE_URL)
	          .then(function(data) { // Notre script PHP renvoie un certain nombre d'informations en JSON (vous savez, grÃ¢ce Ã  notre echo json_encode(...) dans notre script PHP !) qui seront rÃ©cupÃ©rÃ©es ici dans la variable "data"
	            if (data.success) { // Si success est vrai (<=> 1), on peut renvoyer l'id du paiement gÃ©nÃ©rÃ© par PayPal et stockÃ© dans notre data.paypal_reponse (notre script en aura besoin pour poursuivre le processus de paiement)
	               return data.paypal_response.id;   
	            } else { // Sinon, il y a eu une erreur quelque part. On affiche donc Ã  l'utilisateur notre message d'erreur gÃ©nÃ©rÃ© cÃ´tÃ© serveur et passÃ© dans le paramÃ¨tre data.msg, puis on retourne false, ce qui aura pour consÃ©quence de stopper net le processus de paiement.
	               alert(data.msg);
	               return false;   
	            }
	         });
	      },
	      onAuthorize: function(data, actions) {
	        // On indique le chemin vers notre script PHP qui se chargera d'exÃ©cuter le paiement (appelÃ© aprÃ¨s approbation de l'utilisateur cÃ´tÃ© client).
	        var EXECUTE_URL = '/php/paypal_execute_payment.php';
	        // On met en place les donnÃ©es Ã  envoyer Ã  notre script cÃ´tÃ© serveur
	        // Ici, c'est PayPal qui se charge de remplir le paramÃ¨tre data avec les informations importantes :
	        // - paymentID est l'id du paiement que nous avions prÃ©cÃ©demment demandÃ© Ã  PayPal de gÃ©nÃ©rer (cÃ´tÃ© serveur) et que nous avions ensuite retournÃ© dans notre fonction "payment"
	        // - payerID est l'id PayPal de notre client
	        // Ce couple de donnÃ©es nous permettra, une fois envoyÃ© cÃ´tÃ© serveur, d'exÃ©cuter effectivement le paiement (et donc de recevoir le montant du paiement sur notre compte PayPal).
	        // Attention : ces donnÃ©es Ã©tant fournies par PayPal, leur nom ne peut pas Ãªtre modifiÃ© ("paymentID" et "payerID").
	        var data = {
	          paymentID: data.paymentID,
	          payerID: data.payerID
	        };
	        // On envoie la requÃªte Ã  notre script cÃ´tÃ© serveur
	        return paypal.request.post(EXECUTE_URL, data)
	          .then(function (data) { // Notre script renverra une rÃ©ponse (du JSON), Ã  nouveau stockÃ©e dans le paramÃ¨tre "data"
	          if (data.success) { // Si le paiement a bien Ã©tÃ© validÃ©, on peut par exemple rediriger l'utilisateur vers une nouvelle page, ou encore lui afficher un message indiquant que son paiement a bien Ã©tÃ© pris en compte, etc.
	            // Exemple : window.location.replace("Une url quelconque");
	            alert("Paiement approuvÃ© ! Merci !");
	          } else {
	            // Sinon, si "success" n'est pas vrai, cela signifie que l'exÃ©cution du paiement a Ã©chouÃ©. On peut donc afficher notre message d'erreur crÃ©Ã© cÃ´tÃ© serveur et stockÃ© dans "data.msg".
	            alert(data.msg);
	          }
	        });
	      },
	      onCancel: function(data, actions) {
	        alert("Paiement annulÃ© : vous avez fermÃ© la fenÃªtre de paiement.");
	      },
	      onError: function(err) {
	        alert("Paiement annulÃ© : une erreur est survenue. Merci de bien vouloir rÃ©essayer ultÃ©rieurement.");
	      }
	    }, '#bouton-paypal');

Et voilÃ  ! Nous en avons terminÃ© avec l'intÃ©gration de notre systÃ¨me de paiement ! Vous pouvez tester, le systÃ¨me est entiÃ¨rement fonctionnel (du moins si vous avez bien suivi le cours et que vous n'avez fait aucune erreur dans son intÃ©gration ğŸ˜…)...

Cependant, il ne sera peut-Ãªtre pas trÃ¨s viable pour vous de vendre un unique produit sur notre site. On pourrait en effet imaginer un systÃ¨me avec une vente de plusieurs produits stockÃ©s en base de donnÃ©es et des comptes membres pour les acheteurs. Pour Ã§a, il va falloir jeter un coup dâ€™Å“il Ã  la partie suivante ğŸ˜‰
Partager ce contenu
Rejoindre la Newsletter
Obtenir des Credentials
Tests du systÃ¨me et passage en Live
A propos de l'auteur
PrimFX
Boris ('PrimFX')

Je m'appelle Boris, j'ai 20 ans et je suis passionnÃ© d'informatique et de technologie. DiplÃ´mÃ© d'une Licence Informatique de l'UniversitÃ© de Strasbourg, j'ai co-fondÃ© en 2019 l'entreprise Single Quote et je profite de mon temps libre pour partager ma passion Ã  travers des vidÃ©os & articles sur PrimFX.com ğŸ˜ƒ
PrimFX.com

Programmation, dÃ©veloppement web, high-tech, etc. Je partage ma passion pour l'informatique Ã  travers des tutos vidÃ©os et articles en espÃ©rant qu'ils vous soient utiles ;-)
Articles / VidÃ©os

    Tous les articles
    Tutos PHP
    Tutos C

Ã‰change

    Chat (Discord)
    Forum
    CrÃ©er un topic

Ressources

    Rejoindre la newsletter
    Mentions lÃ©gales & CGU
    Contact

Â© 2020 PrimFX.com. Tous droits rÃ©servÃ©s. PropulsÃ© par Single Quote.

